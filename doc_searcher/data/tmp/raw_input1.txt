What's Included in This Documenthttps://www.boost.org/doc/libs/1_53_0/doc/html/about.html   What's Included in This Document           Home Libraries People FAQ More        What's Included in This Document This document represents only a subset of the full Boost     documentation: that part which is generated from BoostBook or     QuickBook sources.  Eventually all Boost libraries may use these     formats, but in the meantime, much of Boost's documentation is not     available here.  Please     see http://www.boost.org/libs     for complete documentation.             Documentation for some of the libraries described in this document is       available in alternative formats:         HTML          PDF                  
Chapter&#160;1.&#160;Boost.Accumulatorshttps://www.boost.org/doc/libs/1_53_0/doc/html/accumulators.html   Chapter&#160;1.&#160;Boost.Accumulators           Home Libraries People FAQ More         Chapter&#160;1.&#160;Boost.Accumulators  Eric Niebler  Copyright &#169; 2005, 2006 Eric Niebler           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Preface User's Guide  The       Accumulators Framework The       Statistical Accumulators Library  Acknowledgements Reference  Accumulators Framework Reference Statistics Library Reference Numeric Operators Library Reference      Preface           &#8220;It is better to be approximately right than exactly wrong.&#8221;         -- Old adage                Description             Boost.Accumulators is both a library for incremental statistical computation       as well as an extensible framework for incremental calculation in general.       The library deals primarily with the concept of an accumulator,       which is a primitive computational entity that accepts data one sample at a       time and maintains some internal state. These accumulators may offload some       of their computations on other accumulators, on which they depend. Accumulators       are grouped within an accumulator set. Boost.Accumulators       resolves the inter-dependencies between accumulators in a set and ensures that       accumulators are processed in the proper order.         Last revised: January 31, 2013 at 01:28:17 GMT         
Struct template allocator_traitshttps://www.boost.org/doc/libs/1_53_0/doc/html/allocator_traits.html   Struct template allocator_traits           Home Libraries People FAQ More         Struct template allocator_traits allocator_traits  Synopsis // In header: &lt;boost/container/allocator_traits.hpp&gt;  template&lt;typename Alloc&gt;  struct allocator_traits {   // types   typedef Alloc             allocator_type;                           typedef Alloc::value_type value_type;                               typedef unspecified       pointer;                                  typedef see_documentation const_pointer;                            typedef see_documentation reference;                                typedef see_documentation const_reference;                          typedef see_documentation void_pointer;                             typedef see_documentation const_void_pointer;                       typedef see_documentation difference_type;                          typedef see_documentation size_type;                                typedef see_documentation propagate_on_container_copy_assignment;   typedef see_documentation propagate_on_container_move_assignment;   typedef see_documentation propagate_on_container_swap;               // member classes/structs/unions   template&lt;typename T&gt;    struct portable_rebind_alloc {     // types     typedef see_documentation type;   };    // public static functions   static pointer allocate(Alloc &amp;, size_type);   static void deallocate(Alloc &amp;, pointer, size_type);   static pointer allocate(Alloc &amp;, size_type, const_void_pointer);   template&lt;typename T&gt; static void destroy(Alloc &amp;, T *);   static size_type max_size(const Alloc &amp;);   static Alloc select_on_container_copy_construction(const Alloc &amp;);   template&lt;typename T, class... Args&gt;      static void construct(Alloc &amp;, T *, Args &amp;&amp;...); };  Description The class template allocator_traits supplies a uniform interface to all allocator types. This class is a C++03-compatible implementation of std::allocator_traits    allocator_traits          public        types    typedef unspecified pointer; Alloc::pointer if such a type exists; otherwise, value_type*     typedef see_documentation const_pointer; Alloc::const_pointer if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::rebind&lt;const     typedef see_documentation reference; Non-standard extension Alloc::reference if such a type exists; otherwise, value_type&amp;     typedef see_documentation const_reference; Non-standard extension Alloc::const_reference if such a type exists ; otherwise, const value_type&amp;     typedef see_documentation void_pointer; Alloc::void_pointer if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;.     typedef see_documentation const_void_pointer; Alloc::const_void_pointer if such a type exists ; otherwis e, pointer_traits&lt;pointer&gt;::rebind&lt;const     typedef see_documentation difference_type; Alloc::difference_type if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::difference_type.     typedef see_documentation size_type; Alloc::size_type if such a type exists ; otherwise, make_unsigned&lt;difference_type&gt;::type     typedef see_documentation propagate_on_container_copy_assignment; Alloc::propagate_on_container_copy_assignment if such a type exists, otherwise an integral_constant type with internal constant static member `value` == false.     typedef see_documentation propagate_on_container_move_assignment; Alloc::propagate_on_container_move_assignment if such a type exists, otherwise an integral_constant type with internal constant static member `value` == false.     typedef see_documentation propagate_on_container_swap; Alloc::propagate_on_container_swap if such a type exists, otherwise an integral_constant type with internal constant static member `value` == false.       allocator_traits public static functions   static pointer allocate(Alloc &amp; a, size_type n); Returns: `a.allocate(n)`    static void deallocate(Alloc &amp; a, pointer p, size_type n); Returns: `a.deallocate(p, n)` Throws: Nothing    static pointer allocate(Alloc &amp; a, size_type n, const_void_pointer p); Effects: calls `a.allocate(n, p)` if that call is well-formed; otherwise, invokes `a.allocate(n)`    template&lt;typename T&gt; static void destroy(Alloc &amp; a, T * p); Effects: calls `a.destroy(p)` if that call is well-formed; otherwise, invokes `p-&gt;~T()`.    static size_type max_size(const Alloc &amp; a); Returns: `a.max_size()` if that expression is well-formed; otherwise, `numeric_limits&lt;size_type&gt;::max()`.    static Alloc select_on_container_copy_construction(const Alloc &amp; a); Returns: `a.select_on_container_copy_construction()` if that expression is well-formed; otherwise, a.    template&lt;typename T, class... Args&gt;    static void construct(Alloc &amp; a, T * p, Args &amp;&amp;... args); Effects: calls `a.construct(p, std::forward&lt;Args&gt;(args)...)` if that call is well-formed; otherwise, invokes `::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)`         Copyright &#169; 2009-2012 Ion       Gaztanaga         Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                
Chapter&#160;2.&#160;Boost.Anyhttps://www.boost.org/doc/libs/1_53_0/doc/html/any.html   Chapter&#160;2.&#160;Boost.Any           Home Libraries People FAQ More         Chapter&#160;2.&#160;Boost.Any  Kevlin Henney  Copyright &#169; 2001 Kevlin Henney  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Examples Reference  ValueType requirements Header &lt;boost/any.hpp&gt;  Acknowledgements     Introduction There are times when a generic (in the sense of     general as opposed to     template-based programming) type is needed:     variables that are truly variable, accommodating values of many     other more specific types rather than C++'s normal strict and     static types. We can distinguish three basic kinds of generic     type:  Converting types that can hold one of a number of         possible value types, e.g. int and         string, and freely convert between them, for         instance interpreting 5 as "5" or         vice-versa.  Such types are common in scripting and other         interpreted         languages.          boost::lexical_cast         supports such conversion functionality.          Discriminated types that contain values of different types but         do not attempt conversion between them, i.e. 5 is         held strictly as an int and is not implicitly         convertible either to "5" or to         5.0. Their indifference to interpretation but         awareness of type effectively makes them safe, generic         containers of single values, with no scope for surprises from         ambiguous conversions.          Indiscriminate types that can refer to anything but are         oblivious to the actual underlying type, entrusting all forms         of access and interpretation to the programmer. This niche is         dominated by void *, which offers plenty of scope         for surprising, undefined behavior.  The boost::any class     (based on the class of the same name described in "Valued     Conversions" by Kevlin Henney, C++     Report 12(7), July/August 2000) is a variant value type     based on the second category. It supports copying of any value     type and safe checked extraction of that value strictly against     its type. A similar design, offering more appropriate operators,     can be used for a generalized function adaptor,     any_function, a generalized iterator adaptor,     any_iterator, and other object types that need     uniform runtime treatment but support only compile-time template     parameter conformance.    Last revised: July 26, 2009 at 21:11:03 +0100         
Chapter&#160;3.&#160;Boost.Arrayhttps://www.boost.org/doc/libs/1_53_0/doc/html/array.html   Chapter&#160;3.&#160;Boost.Array           Home Libraries People FAQ More         Chapter&#160;3.&#160;Boost.Array  Nicolai Josuttis  Copyright &#169; 2001-2004 Nicolai M. Josuttis  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction Reference Header &lt;boost/array.hpp&gt; Design Rationale For more information... Acknowledgements     Introduction The C++ Standard Template Library STL as part of the C++     Standard Library provides a framework for processing algorithms on     different kind of containers. However, ordinary arrays don't     provide the interface of STL containers (although, they provide     the iterator interface of STL containers). As replacement for ordinary arrays, the STL provides class     std::vector.  However,     std::vector&lt;&gt; provides     the semantics of dynamic arrays. Thus, it manages data to be able     to change the number of elements. This results in some overhead in     case only arrays with static size are needed. In his book, Generic Programming and the     STL, Matthew H. Austern introduces a useful wrapper     class for ordinary arrays with static size, called     block.  It is safer and has no worse performance than     ordinary arrays. In The C++ Programming     Language, 3rd edition, Bjarne Stroustrup introduces a     similar class, called c_array, which I (Nicolai Josuttis) present     slightly modified in my book The C++ Standard Library -     A Tutorial and Reference, called     carray. This is the essence of these approaches     spiced with many feedback from boost. After considering different names, we decided to name this     class simply array. Note that this class is suggested to be part of the next     Technical Report, which will extend the C++ Standard (see     http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1548.htm). Update: std::array is (as of C++11) part of the C++ standard.     The differences between boost::array and std::array are minimal.     If you are using C++11, you should consider using std::array instead of boost::array.      Class array fulfills most     but not all of the requirements of "reversible containers" (see     Section 23.1, [lib.container.requirements] of the C++     Standard). The reasons array is not an reversible STL container is     because:         No constructors are provided. Elements may have an undetermined initial value (see the section called &#8220;Design Rationale&#8221;).  swap() has no constant complexity.  size() is always constant, based on the second template argument of the type. The container provides no allocator support.        It doesn't fulfill the requirements of a "sequence" (see Section 23.1.1, [lib.sequence.reqmts] of the C++ Standard), except that:          front() and back() are provided.  operator[] and at() are provided.           Last revised: June 14, 2012 at 17:01:03 +0100         
Concept Assignablehttps://www.boost.org/doc/libs/1_53_0/doc/html/Assignable.html   Concept Assignable           Home Libraries People FAQ More         Concept Assignable Assignable   Description Assignable types must have copy constructors,     operator= for assignment, and the swap()     function defined.   Refinement of CopyConstructible   Notation  X A type playing the role of assignable-type in the Assignable concept.  x, y  Objects of type X    Valid expressions         Name Expression Type Semantics    Assignment x = y X &amp; Require operator=   Swap swap(x, y) void Require swap() function      Models int   See also CopyConstructible     Copyright &#169; 2001, 2002 Indiana UniversityCopyright &#169; 2000, 2001 University of Notre Dame du LacCopyright &#169; 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright &#169; 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright &#169; 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)        This product includes software developed at the University       of Notre Dame and the Pervasive Technology Labs at Indiana       University. For technical information contact Andrew Lumsdaine       at the Pervasive Technology Labs at Indiana University.  For       administrative and license questions contact the Advanced       Research and Technology Institute at 351 West 10th Street.       Indianapolis, Indiana 46202, phone 317-278-4100, fax       317-274-5902. Some concepts based on versions from the MTL draft manual       and Boost Graph and Property Map documentation, the SGI Standard       Template Library documentation and the Hewlett-Packard STL,       under the following license:           Permission to use, copy, modify, distribute and         sell this software and its documentation for any purpose is         hereby granted without fee, provided that the above copyright         notice appears in all copies and that both that copyright         notice and this permission notice appear in supporting         documentation.  Silicon Graphics makes no representations         about the suitability of this software for any purpose.  It is         provided "as is" without express or implied         warranty.         
Chapter&#160;4.&#160;Boost.Atomichttps://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html   Chapter&#160;4.&#160;Boost.Atomic           Home Libraries People FAQ More         Chapter&#160;4.&#160;Boost.Atomic  Helge Bahmann  Copyright &#169; 2011 Helge Bahmann Copyright &#169; 2012 Tim Blechmann           Distributed under the Boost Software License, Version 1.0. (See accompanying         file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  Introduction  Presenting       Boost.Atomic Purpose  Thread coordination using Boost.Atomic  Enforcing happens-before       through mutual exclusion happens-before       through release and acquire Fences happens-before       through release and consume Sequential consistency  Programming interfaces  Memory order Atomic objects Fences Feature testing macros  Usage examples  Reference       counting Spinlock Singleton with       double-checked locking pattern Wait-free       ring buffer Wait-free multi-producer       queue  Limitations Porting  Unit tests Tested compilers      Introduction   Presenting       Boost.Atomic Purpose    Presenting       Boost.Atomic           Boost.Atomic is a library that provides         atomic data types and operations on these data types,         as well as memory ordering constraints required for coordinating multiple         threads through atomic variables. It implements the interface as defined         by the C++11 standard, but makes this feature available for platforms lacking         system/compiler support for this particular C++11 feature.                 Users of this library should already be familiar with concurrency in general,         as well as elementary concepts such as "mutual exclusion".                 The implementation makes use of processor-specific instructions where possible         (via inline assembler, platform libraries or compiler intrinsics), and falls         back to "emulating" atomic operations through locking.           Purpose           Operations on "ordinary" variables are not guaranteed to be atomic.         This means that with int n=0 initially, two threads concurrently         executing        void function() {   n ++; }           might result in n==1 instead of 2: Each thread will read         the old value into a processor register, increment it and write the result         back. Both threads may therefore write 1, unaware that         the other thread is doing likewise.                 Declaring atomic&lt;int&gt; n=0 instead, the same operation         on this variable will always result in n==2 as each operation         on this variable is atomic: This means that each operation         behaves as if it were strictly sequentialized with respect to the other.                 Atomic variables are useful for two purposes:                      as a means for coordinating multiple threads via custom coordination             protocols                         as faster alternatives to "locked" access to simple variables                      Take a look at the examples         section for common patterns.            Last revised: January 31, 2013 at 01:29:56 GMT         
Chapter&#160;41.&#160;Boost.Build V2 User Manualhttps://www.boost.org/doc/libs/1_53_0/doc/html/bbv2.html   Chapter&#160;41.&#160;Boost.Build V2 User Manual           Home Libraries People FAQ More         Chapter&#160;41.&#160;Boost.Build V2 User Manual Copyright &#169; 2006-2009 Vladimir Prus  Distributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)           Table of Contents  How to use this document Installation Tutorial  Hello, world Properties Project Hierarchies Dependent Targets Static and shared libaries Conditions and alternatives Prebuilt targets  Overview  Concepts Boost.Jam Language Configuration Invocation Declaring Targets Projects The Build Process  Common tasks  Programs Libraries Alias Installing Testing Custom commands Precompiled Headers Generated headers Cross-compilation  Reference  General information Builtin rules Builtin features Builtin tools Builtin modules Builtin classes Build process Definitions  Extender Manual  Introduction Example: 1-to-1 generator Target types Tools and generators Features Main target rules Toolset modules  Frequently Asked Questions         How do I get the current value of feature in Jamfile?             I am getting a "Duplicate name of actual target" error. What does that       mean?             Accessing environment variables             How to control properties order?             How to control the library linking order on Unix?             Can I get capture external program output using a Boost.Jam variable?             How to get the project root (a.k.a. Jamroot) location?             How to change compilation flags for one file?             Why are the dll-path and hardcode-dll-paths        properties useful?      Targets in site-config.jam Header-only libraries      How to use this document        If you've just found out about Boost.Build V2 and want to know       if it will work for you, start with the section called &#8220;Tutorial&#8221;. You can continue with the section called &#8220;Overview&#8221;. When you're ready to try Boost.Build       in practice, go to the section called &#8220;Installation&#8221;.             If you are about to use Boost.Build on your project, or already       using it and have a problem, look at the section called &#8220;Overview&#8221;.             If you're trying to build a project which uses Boost.Build,       see the section called &#8220;Installation&#8221; and then read about       the section called &#8220;Invocation&#8221;.             If you have questions, please post them to our mailing list (http://boost.org/more/mailing_lists.htm#jamboost). The mailing list is       also mirrored to the newsgroup news://news.gmane.org/gmane.comp.lib.boost.build.                  
Concept BidirectionalIteratorhttps://www.boost.org/doc/libs/1_53_0/doc/html/BidirectionalIterator.html   Concept BidirectionalIterator           Home Libraries People FAQ More         Concept BidirectionalIterator BidirectionalIterator   Description A bidirectional iterator is an iterator that can read through a sequence   of values.  It can move in either direction through the sequence, and can   be either mutable (data pointed to by it can be changed) or not mutable. An iterator represents a position in a sequence.  Therefore, the   iterator can point into the sequence (returning a value when dereferenced   and being incrementable), or be off-the-end (and not dereferenceable or   incrementable).   Refinement of ForwardIterator   Associated types   value_type std::iterator_traits&lt;Iter&gt;::value_type The value type of the iterator   category std::iterator_traits&lt;Iter&gt;::iterator_category The category of the iterator     Notation  Iter A type playing the role of iterator-type in the BidirectionalIterator concept.  i, j  Objects of type Iter x Object of type value_type    Type expressions  Category tag category must be                   derived from std::bidirectional_iterator_tag.                     Valid expressions           Name Expression Type Precondition Semantics Postcondition    Predecrement --i Iter &amp; i is incrementable (not     off-the-end) and some dereferenceable iterator j exists     such that i == ++j &#160; &#160;   Postdecrement i-- Iter Same as for predecrement Equivalent to {Iter j = i; --i; return j;} i is dereferenceable or     off-the-end      Complexity    All iterator operations must take amortized constant time.      Invariants  Predecrement must return object    &amp;i = &amp;(--i)    Unique path through sequence    i == j implies --i == --j    Increment and decrement are inverses    ++i; --i; and --i; ++i; must end up with the   value of i unmodified, if i both of the   operations in the pair are valid.       Models  T * std::list&lt;T&gt;::iterator    See also RandomAccessIterator     Copyright &#169; 2001, 2002 Indiana UniversityCopyright &#169; 2000, 2001 University of Notre Dame du LacCopyright &#169; 2000 Jeremy Siek, Lie-Quan Lee, Andrew LumsdaineCopyright &#169; 1996-1999 Silicon Graphics Computer Systems, Inc.Copyright &#169; 1994 Hewlett-Packard CompanyDistributed under the Boost Software License, Version 1.0.       (See accompanying file LICENSE_1_0.txt or copy at        http://www.boost.org/LICENSE_1_0.txt)        This product includes software developed at the University       of Notre Dame and the Pervasive Technology Labs at Indiana       University. For technical information contact Andrew Lumsdaine       at the Pervasive Technology Labs at Indiana University.  For       administrative and license questions contact the Advanced       Research and Technology Institute at 351 West 10th Street.       Indianapolis, Indiana 46202, phone 317-278-4100, fax       317-274-5902. Some concepts based on versions from the MTL draft manual       and Boost Graph and Property Map documentation, the SGI Standard       Template Library documentation and the Hewlett-Packard STL,       under the following license:           Permission to use, copy, modify, distribute and         sell this software and its documentation for any purpose is         hereby granted without fee, provided that the above copyright         notice appears in all copies and that both that copyright         notice and this permission notice appear in supporting         documentation.  Silicon Graphics makes no representations         about the suitability of this software for any purpose.  It is         provided "as is" without express or implied         warranty.         